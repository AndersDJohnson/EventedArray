// Generated by CoffeeScript 1.4.0
(function() {
  var AbstractArray, AbstractEvent, EventEmitter2, EventedArray, method, _i, _j, _len, _len1, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter2 = require('eventemitter2').EventEmitter2;

  AbstractArray = require('./AbstractArray');

  AbstractEvent = require('./AbstractEvent');

  EventedArray = (function(_super) {

    __extends(EventedArray, _super);

    /*
    	# @see https://github.com/hij1nx/EventEmitter2/blob/master/README.md#api
    */


    EventedArray.wrappedEventEmitter2Methods = ['addListener', 'on', 'onAny', 'offAny', 'once', 'many', 'removeListener', 'off', 'removeAllListeners', 'setMaxListeners', 'listeners', 'listenersAny', 'emit'];

    function EventedArray() {
      EventedArray.__super__.constructor.apply(this, arguments);
      this._emitter = new EventEmitter2({
        wildcard: false,
        newListener: false,
        maxListeners: 0
      });
    }

    EventedArray.prototype.set = function(index, value) {
      var args, e1, e1type, e2, e2type, ret;
      ret = void 0;
      args = Array.prototype.slice.call(arguments);
      e1type = 'before.set';
      e1 = new AbstractEvent({
        type: e1type
      });
      this._emitter.emit.apply(this._emitter, [e1type, e1].concat(args));
      if (!e1.defaultPrevented) {
        ret = this._array[index] = value;
      }
      e2type = 'after.set';
      e2 = new AbstractEvent({
        type: e2type
      });
      this._emitter.emit.apply(this._emitter, [e2type, e2].concat(args));
      return ret;
    };

    EventedArray.prototype.get = function(index) {
      var args, e1, e1type, e2, e2type, ret;
      ret = void 0;
      args = Array.prototype.slice.call(arguments);
      e1type = 'before.get';
      e1 = new AbstractEvent({
        type: e1type
      });
      this._emitter.emit.apply(this._emitter, [e1type, e1].concat(args));
      if (!e1.defaultPrevented) {
        ret = this._array[index];
      }
      e2type = 'after.get';
      e2 = new AbstractEvent({
        type: e2type
      });
      this._emitter.emit.apply(this._emitter, [e2type, e2].concat(args));
      return ret;
    };

    return EventedArray;

  })(AbstractArray);

  _ref = EventedArray.wrappedEventEmitter2Methods;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    method = _ref[_i];
    EventedArray.prototype[method] = (function(meth) {
      return function() {
        var args;
        args = Array.prototype.slice.call(arguments);
        return this._emitter[meth].apply(this._emitter, args);
      };
    })(method);
  }

  _ref1 = AbstractArray.wrappedArrayMethods;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    method = _ref1[_j];
    EventedArray.prototype[method] = (function(meth) {
      return function() {
        var args, e1, e1type, e2, e2type, ret;
        ret = void 0;
        args = Array.prototype.slice.call(arguments);
        e1type = 'before.' + meth;
        e1 = new AbstractEvent({
          type: e1type
        });
        this._emitter.emit.apply(this._emitter, [e1type, e1].concat(args));
        if (!e1.defaultPrevented) {
          ret = this._array[meth].apply(this._array, args);
        }
        e2type = 'after.' + meth;
        e2 = new AbstractEvent({
          type: e2type
        });
        this._emitter.emit.apply(this._emitter, [e2type, e2].concat(args));
        return ret;
      };
    })(method);
  }

  module.exports = EventedArray;

}).call(this);
